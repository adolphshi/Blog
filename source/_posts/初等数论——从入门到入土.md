---
layout: blog
title: 初等数论——从入门到入土
date: 2024-08-01T16:00:00.000Z
updated: 2024-08-01T16:00:00.000Z
cover: /images/uploads/snipaste_2024-08-01_16-19-54.png
tags:
  - OI
  - 算法
  - 数学
categories:
  - 算法学习
---


这个是集训时的内容，原先说是基础数论（从同余开始讲的那种），结果一上午就讲完了，于是下午就拓展了很多的内容。~~上午入门，下午入土~~

本文的 $\LaTeX$ 代码可能较多，加载可能需要一点时间，如果公式炸了请在下面提醒我。

## 0x00 一些约定

下面为了表述方便，故采用一些特定的约定。**以下若无特别说明，均默认为整数。**

$p$  代表质数  ,$m$ 通常代表模数。

在代码中 `p` 为模数， `inv` 为逆元

## 0x10 同余

这个是最为基本的，所以我也就简单讲一下。

### 0x11 余数
  
回顾一下小学的内容：  
$$ a \div b =  c \cdots d$$  
其中 $a、b、c、d$ 均为整数,$a$ 被称作被除数，$b$ 被称作除数，$c$ 被称作商，$d$ 被称作余数。

如果我们现在只关心被除数、除数与余数的关系，那么上式还可以被写作：  
$$a \equiv d (\pmod b)$$  
$d$ 叫做 $a$ 在**模** $b$ 意义下的余数。其中 $\equiv$ 叫做恒等于， $\mod$ 叫做取模（就是取余数的意思），$b$ 被称为模数。

如果我们将第一个式子变换一下，还可以得到下面的这个式子~~其实这才是余数的定义~~：  
$$a=b\times c+d$$  
再将这个式子与第二个式子一起看，我们就发现了消去恒等于和取模的方法，这可能会使下面的证明更易懂一些。

特别的，当 $a \equiv 0 (\mod b)$  时，也就是余数等于 $0$ 时，我们称 **a被b整除**,记作 $b|a$ 。**注意：是右边被左边整除**
	
整除有很多的性质，这些都是很显然的，等用到了我再说。

### 0x12 同余式

其实上一部分中的 $a \equiv d (\mod b)$  就是同余式，同余与等式有着类似的关系，即满足自反性，对称性，传递性。（~~恒等于里也带一个等于呢~~）

同时，同余还满足以下几种关系：
若 $a\equiv b (\mod m)$，且 $c\equiv d(\mod m)$ （注意模数相同）  
则有  
$$a+c\equiv b+d (\mod m)$$  
$$a\times c\equiv b\times d (\mod m)$$  
所以就是恒等式两边同时加或乘一个数，同余依旧成立。(**注意没有除法**)  
但是除法有下面一个式子:  
若 $a,b\in\mathbf{Z},d,m\in\mathbf{N}^*,d\mid a,d\mid b,d\mid m$ ，则当 $a\equiv (b\mod m)$ 成立时，有
$\dfrac{a}{d} \equiv \dfrac{b}{d} \left(\mod\;{\dfrac{m}{d}}\right)$  
证明就是将上个式子转成余数的定义式再整体除以d就出来了。

## 0x20 乘法逆元

我们发现，再同余式中，相同模数的加减乘都非常方便计算，但是除法并不是那么容易进行计算。所以我们引入了一个乘法逆元的概念。

我们定义若有 $ax \equiv 1 (\pmod m)$ 则称 $a$ 为 $x$ 在 $\mod m$ 意义下的逆元,记作$a^{-1}$。（~~其实就是群论的逆元的一种形式~~） 简单理解就是因为在除法里 $a\div a=1=a\dfrac{1}{a}$，所以在数论中**一个数除以另一个数就相当于乘以那个数的逆元**。

### 0x21 费马小定理求逆元

这是在信息学竞赛中较为常用的求逆元方法，适用于**模数为质数**的情况。其核心原理为费马小定理，费马小定理内容如下：
若 $p$ 为质数且与 $a$ 互质，那么就有
$$a^{p-1}\equiv 1 (\mod p)$$

由费马小定理可得
$aa^{p-2}\equiv 1 (\mod p)$

再结合定义式,就可以得到 $a^{p-2}$ 就是 $a$ 在 $\mod p$ 意义下的逆元。

{%spoiler 代码实现%}

这个实现是最简单的，只需要用到快速幂即可。（什么，你还没有学过[快速幂](https://www.luogu.com.cn/problem/P1226)）
```cpp
int ksm(int x,int y)
{
	int res=1;
	while(y)
	{
		if(y&1) res=1ll*res*x%p;
		x=1ll*x*x%p;
		y>>=1;
	}
	return res;
}//求逆元时 inv=ksm(n,p-2);
```


{%endspoiler%}
