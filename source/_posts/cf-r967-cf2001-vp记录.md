---
layout: blog
title: CF R967 (CF2001) VP记录
date: 2024-08-30T14:53:00.000Z
cover: https://cdn.luogu.com.cn/upload/image_hosting/imbnzgmv.png
coverWidth: "1200"
coverHeight: "750"
tags:
  - VP
  - OI
categories:
  - CF补全计划
---

solved（3/6）

## CF2001A Make All Equal

### 题意
您将得到一个循环数组 $$a_1, a_2, \ldots, a_n$$ 。您最多可以对 $$a$$ 执行 $$n - 1$$ 次以下操作：

- 设 $$m$$ 为 $$a$$ 的当前大小，
您可以选择任意两个相邻的元素，其中前一个元素不大于后一个元素(特别是， $$a_m$$ 和 $$a _1$$ 是相邻的，$$a_m$$ 是前一个)，并只删除其中一个。换句话说，选择一个整数 $$i$$ ( $$1 \leq i \leq m$$ )其中 $$a_i \leq a_{(i \bmod m) + 1}$$ 成立，并从 $$a$$ 中删除 $$a_i$$ 或 $$a_{(i \bmod m) + 1}$$ 中的一个。

您的目标是找到使 $$a$$ 中的所有元素相等所需的最少操作数。

### 思路

这个真的很简单，我们考虑有一个数，如果他前面的数比他小，那么就可以直接删去，如果比它大就继续向前看。

我们会发现，无论如何我们都可以删去前面的数，所以我们可以保留出现次数做多的数，这样的操作次数最少。

### code

{%spoiler code%}
``` cpp
#include <bits/stdc++.h>
#define _F(x,y,z) for(int x=y;x<=z;x++)
#define F_(x,z,y) for(int x=z;x>=y;x--)
#define TF(x,y,z) for(int x=head[y],z;x;x=nex[x])

using namespace std;

typedef long long ll;
typedef double dou;
typedef const int ci;
typedef pair<int,int> pii;

ci maxn=2e6+10;

int n,t,cnt[110],ans;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		ans=0;memset(cnt,0,sizeof cnt);
		scanf("%d",&n);
		_F(i,1,n)
		{
			int x;
			scanf("%d",&x);
			cnt[x]++;
			ans=max(ans,cnt[x]);
		}
		printf("%d\n",n-ans);
	}
	return 0;
}
```
{%endspoiler%}

## CF2001B Generate Permutation
### 题意
有一个长度为 $n$ 的整数序列 $a$ ，其中每个元素的初始值为 $-1$ 。

美雪有两台打字机，第一台打字机从左往右写字母，指针最初指向 $1$ ，另一台打字机从右往左写字母，指针最初指向 $n$ 。

美雪会选择其中一台打字机进行以下操作，直到 $a$ 变成 $[1, 2, \ldots, n]$ 的排列。

- 写数：将数组 $a$ 中不存在的最小**正**整数写入元素 $a_i$ ， $i$ 是指针指向的位置。这种操作只有在 $a_i = -1$ 时才能执行。

- 回车：将指针返回到初始位置（例如，第一台打字机为 $1$ ，第二台为 $n$

- 移动指针：将指针移动到下一个位置，假设 $i$ 是指针在执行此操作前所指向的位置，如果美幸使用的是第一台打字机，则为 $i := i + 1$ ，否则为 $i := i - 1$ 。只有在操作之后， $1 \le i \le n$ 成立时，才能执行此操作。

你的任务是构造长度为 $n$ 的任意排列 $p$ ，使得无论美雪使用哪台打字机， $a = p$ 所需的最小回车操作次数都相同。
### 思路

首先先理解一下题面，
