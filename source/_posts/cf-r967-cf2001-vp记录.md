---
layout: blog
title: CF R967 (CF2001) VP记录
date: 2024-08-30T14:53:00.000Z
cover: https://cdn.luogu.com.cn/upload/image_hosting/imbnzgmv.png
coverWidth: "1200"
coverHeight: "750"
tags:
  - VP
  - OI
categories:
  - CF补全计划
---

solved（3/6）

## CF2001A Make All Equal

### 题意
您将得到一个循环数组 $$a_1, a_2, \ldots, a_n$$ 。您最多可以对 $$a$$ 执行 $$n - 1$$ 次以下操作：

- 设 $$m$$ 为 $$a$$ 的当前大小，
您可以选择任意两个相邻的元素，其中前一个元素不大于后一个元素(特别是， $$a_m$$ 和 $$a _1$$ 是相邻的，$$a_m$$ 是前一个)，并只删除其中一个。换句话说，选择一个整数 $$i$$ ( $$1 \leq i \leq m$$ )其中 $$a_i \leq a_{(i \bmod m) + 1}$$ 成立，并从 $$a$$ 中删除 $$a_i$$ 或 $$a_{(i \bmod m) + 1}$$ 中的一个。

您的目标是找到使 $$a$$ 中的所有元素相等所需的最少操作数。

### 思路

这个真的很简单，我们考虑有一个数，如果他前面的数比他小，那么就可以直接删去，如果比它大就继续向前看。

我们会发现，无论如何我们都可以删去前面的数，所以我们可以保留出现次数做多的数，这样的操作次数最少。

### code

{%spoiler code%}
``` cpp
#include <bits/stdc++.h>
#define _F(x,y,z) for(int x=y;x<=z;x++)
#define F_(x,z,y) for(int x=z;x>=y;x--)
#define TF(x,y,z) for(int x=head[y],z;x;x=nex[x])

using namespace std;

typedef long long ll;
typedef double dou;
typedef const int ci;
typedef pair<int,int> pii;

ci maxn=2e6+10;

int n,t,cnt[110],ans;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		ans=0;memset(cnt,0,sizeof cnt);
		scanf("%d",&n);
		_F(i,1,n)
		{
			int x;
			scanf("%d",&x);
			cnt[x]++;
			ans=max(ans,cnt[x]);
		}
		printf("%d\n",n-ans);
	}
	return 0;
}
```
{%endspoiler%}
